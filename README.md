# MyComponents

Некоторые компоненты отчасти собственной разработки с самой простейшей реализацией. Документация по методам компонентов есть в виде комментариев в файлах самих компонентов.

_В папке QueryBuilder pdo подключение происходит по моей локальной конфигурации, поменяйте кофигурации для подключения если хотите убедиться в работоспосбности компонента самостоятельно_

- [Компонент QueryBuilder](#querybuilder)
- [Компонент Router](#router)
- [Компонент Validator](#validator)
- [Компонент Flash](#flash)

## QueryBuilder

Данный компонент отвечает за работы с базой данных и был реализован на 2 уровне с помощью шаблона одиночка, который позволяет работать с одним объектом класса через метод getInstance(), не создавая новые. Класс позволяет получить, удалить, добавить и обновить информацию в БД. При этом есть возможность посмотреть на ошибки выполнения запроса в случае неудачи.

_В данной папке pdo подключение происходит по моей локальной конфигурации, поменяйте кофигурации для подключения если хотите убедиться в работоспосбности компонента самостоятельно_

### Содержание:

- css
    - main.css - стили для view
- public
    - index.php - точка входа с примером работы с компонентом
- QueryBuilder.php - компонент QueryBuilder
- index.view.php - view для наглядности

### Использование

Все методы надо использовать через статический метод getInstance(). В моем примере я заранее создал несколько строк с полями id и title. Значение последней строки задал trash.

1. Для удаления строк нужно вызвать метод delete() и указать таблицу и критерии отбора. В данном случае я удаляю все строки где в поле title значение trash.
```php
    QueryBuilder::getInstance()->delete('posts', ['title', '=', 'trash']);    
```

2. Далее для добавления строки используется метод insert() с указанием таблицы и информации в виде массива с полями и значениями. После предыдущего шага я добавляю строку с тем же названием trash. В данном случае id увеличится на один (т.к. мы удалили строку и создали новую, а не обновили старую).
```php
    QueryBuilder::getInstance()->insert('posts', [
        'title' => 'trash',
    ]);
```

3. Для обновления строки с помощью метода update() нужно указать таблицу, id строки для изменения и информацию для записи. В данном примере я обновляю поле title строки с id 2 добавляя к нему точку.
```php
    QueryBuilder::getInstance()->update('posts', 2, [
        'title' => QueryBuilder::getInstance()->get('posts', ['id', '=', '2'])->first()['title'] . '.',
    ]
    );
```

4. Для получения строк из БД используется метод get() с параметрами таблицы и отбора строк. В данном примере выполняется запрос на получение всех строк с id больше 0 (т.е. все). На следующей строке кода происходит присваивание результата выполнения запроса с помощью метода results(). Данный пример демонстрирует работу шаблона одиночка, так как создается не новый объект а возвращается старый, с помощью которого был выполнен запрос и куда был записан результат.
```php
    QueryBuilder::getInstance()->get('posts', ['id', '>', 0]);
    $posts = QueryBuilder::getInstance()->results();
```

## Router

Для работы компонента нужен постоянный список путей в виде массива, который нельзя поместить в глобальную переменную, как сообщения в сессию. Поэтому для этого в отдельном файле (в моем случае в индексе чисто для примера) нужно будет создавать массив, как для конфигурации, который потом будет подключатся в index.php.

В компоненте всего один статический (для удобства, смысла создавать объект нет) метод, который просто подключает файл по входному запросу сверяясь с массивом запросов, который также поступает на вход в метод. Изменение массива с путями производится вручную в соответствубщим файле, поэтому нет методов с добавлением или удалением путей.

### Содержание:

- controllers - папка со страницами для примера
    - about.php - вывод 'about'
    - homepage.php - вывод 'homepage'
- public
    - index.php - точка входа с массивом и использованным методом
- Router.php - компонент маршрутизатор

### Использование 

1. Пишем массив с путями в начальном файле либо в отдельном.
```php
    $routes = [
        '/' => 'functions/homepage.php',
        '/about' => 'functions/about.php',
    ];
```

2. Получаем url запрос.
```php
    $route = $_SERVER['REQUEST_URI'];
```
3. Используем статический метод route компонента Router.
```php
    Router::route($route, $routes);
```

## Validator

Данный компонент необходим для валидации информации чаще всего введенной в форму. В данном компоненте главным методом является check() который производит саму валидацию. Результат записывается в переменную passed, а ошибки в массив errors.

### Содержание:

- public
    - index.php - точка входа с примером работы с компонентом
- Validator.php - компонент валидации
- index.view.php - view для наглядности

### Использование

В данном примере используется форма регистрации с полями имени пользователя, электронной почты, паролем и его подтверждением.

1. Создаем объект класса и применяем метод check(), в котором указываем массив $_POST, в котором пришли данные из формы, и массив с требованиями. В данном случае для поля имени существуют требования обязательного наличия, минимальной длины 2 символа и максимальной в 15 символов. Для электронной почты есть требование, чтобы значение действительно являлось электронной почты. Также подтверждение пароля должно совпадать со значением поля пароля.
```php
    $validate = new Validator();

    $validation = $validate->check($_POST, [
        'username' => [
            'required' => true,
            'min' => 2,
            'max' => 15,
        ],
        'email' => [
            'required' => true,
            'email' => true,
        ],
        'password' => [
            'required' => true,
            'min' => 3,
        ],
        'password_again' => [
            'required' => true,
            'matches' => 'password',
        ],
    ]);
```

2. Проверка прошла и результаты записаны в переменные объекта. Создаем условную конструкцию, где при прохождении валидации выводится сообщение, и в обратном случае выводится список ошибок.
```php
    if ($validation->passed()) {
        echo 'validation passed!!!';
    } else {
        foreach ($validation->errors() as $error) {
            echo $error . '<br>';
        }
    };
```

## Flash

Компонент Flash отвечает за работу с флэш сообщениями. Записывает их в сессию и возвращает их с последующим удалением из сессии. Все это работает с помощью статического метода flashMessage().

### Содержание:

- public
    - index.php - точка входа с примером работы с компонентом
- Flash.php - компонент Flash

### Использование 

1. Создаем два флэш сообщения с помощью метода flashMessage(), введя их имена и значения.
```php
    Flash::flashMessage('first', 'first message');
    Flash::flashMessage('second', 'second message');
```

2. Выводим первое сообщение, указав лишь его имя, и проверяем массив $_SESSION. В сессии осталось лиш второе сообщение значит метод сработал правильно.
```php
    echo Flash::flashMessage('first');

    var_dump($_SESSION);
```

3. Выводим второе сообщение.
```php
    echo Flash::flashMessage('second');
```
