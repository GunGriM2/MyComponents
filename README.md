# MyComponents

Некоторые компоненты отчасти собственной разработки с простейшей реализацией. Документация по методам компонентов есть в виде комментариев в файлах самих компонентов.

_В данных файлах pdo подключение происходит по моей локальной конфигурации, поменяйте кофигурации для подключения если хотите убедиться в работоспосбности компонента самостоятельно_

## QueryBuilder

Данный компонент отвечает за работы с базой данных и был реализован на 2 уровне с помощью шаблона одиночка, который позволяет работать с одним объектом класса через метод getInstance(), не создавая новые. Класс позволяет получить, удалить, добавить и обновить информацию в БД. При этом есть возможность посмотреть на ошибки выполнения запроса в случае неудачи.

### Содержание:

- css
    - main.css - стили для view
- public
    - index.php - точка входа с примером работы с компонентом
- QueryBuilder.php - компонент QueryBuilder
- index.view.php - view для наглядности

### Использование

Все методы надо использовать через статический метод getInstance(). В моем примере я заранее создал несколько строк с полями id и title. Значение последней строки задал trash.

1. Для удаления строк нужно вызвать метод delete() и указать таблицу и критерии отбора. В данном случае я удаляю все строки где в поле title значение trash.
```php
    QueryBuilder::getInstance()->delete('posts', ['title', '=', 'trash']);    
```

2. Далее для добавления строки используется метод insert() с указанием таблицы и информации в виде массива с полями и значениями. После предыдущего шага я добавляю строку с тем же названием trash. В данном случае id увеличится на один (т.к. мы удалили строку и создали новую, а не обновили старую).
```php
    QueryBuilder::getInstance()->insert('posts', [
        'title' => 'trash',
    ]);
```

3. Для обновления строки с помощью метода update() нужно указать таблицу, id строки для изменения и информацию для записи. В данном примере я обновляю поле title строки с id 2 добавляя к нему точку.
```php
    QueryBuilder::getInstance()->update('posts', 2, [
        'title' => QueryBuilder::getInstance()->get('posts', ['id', '=', '2'])->first()['title'] . '.',
    ]
    );
```

4. Для получения строк из БД используется метод get() с параметрами таблицы и отбора строк. В данном примере выполняется запрос на получение всех строк с id больше 0 (т.е. все). На следующей строке кода происходит присваивание результата выполнения запроса с помощью метода results(). Данный пример демонстрирует работу шаблона одиночка, так как создается не новый объект а возвращается старый, с помощью которого был выполнен запрос и куда был записан результат.
```php
    QueryBuilder::getInstance()->get('posts', ['id', '>', 0]);
    $posts = QueryBuilder::getInstance()->results();
```

## Router

Для работы компонента нужен постоянный список путей в виде массива, который нельзя поместить в глобальную переменную, как сообщения в сессию. Поэтому для этого в отдельном файле (в моем случае в индексе чисто для примера) нужно будет создавать массив, как для конфигурации, который потом будет подключатся в index.php.

В компоненте всего один статический (для удобства, смысла создавать объект нет) метод, который просто подключает файл по входному запросу сверяясь с массивом запросов, который также поступает на вход в метод. Изменение массива с путями производится вручную в соответствубщим файле, поэтому нет методов с добавлением или удалением путей.

### Содержание:

- controllers - папка со страницами для примера
    - about.php - вывод 'about'
    - homepage.php - вывод 'homepage'
- public
    - index.php - точка входа с массивом и использованным методом
- Router.php - компонент маршрутизатор

### Использование 

1. Пишем массив с путями в начальном файле либо в отдельном.
```php
    $routes = [
        '/' => 'functions/homepage.php',
        '/about' => 'functions/about.php',
    ];
```

2. Получаем url запрос.
```php
    $route = $_SERVER['REQUEST_URI'];
```
3. Используем статический метод route компонента Router.
```php
    Router::route($route, $routes);
```

## Validator

## Flash
